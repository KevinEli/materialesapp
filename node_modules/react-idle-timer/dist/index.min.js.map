{"version":3,"file":"index.min.js","sources":["../src/utils.js","../src/IdleTimer.js","../src/useIdleTimer.js"],"sourcesContent":["/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  return function (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else if (props.onAction) {\n      this._onAction = props.onAction\n\n    // Set default onAction\n    } else {\n      this._onAction = () => {}\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this._handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this._handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed ðŸš€\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    // Bind the event listeners\n    this._bindEvents()\n    // If startOnMount is enabled start the timer\n    const { startOnMount } = this.props\n    if (startOnMount) this.reset()\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if (prevProps.debounce !== this.props.debounce) {\n      this._onAction = debounced(this._onAction, this.props.debounce)\n    }\n    // Update throttle function\n    if (prevProps.throttle !== this.props.throttle) {\n      this._onAction = throttled(this._onAction, this.props.throttle)\n    }\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._handleEvent = throttled(this._handleEvent, this.props.eventsThrottle)\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this._toggleIdleState()\n      if (this.tid !== null) this.reset()\n    }\n  }\n\n  /**\n   * Called before the component unmounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this._handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this._handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        onIdle(e)\n      } else {\n        if (!stopOnIdle) {\n          this._bindEvents()\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = this.getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Restore initial state and restart timer\n   * @name reset\n   */\n  reset () {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause () {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume () {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  stopOnIdle: false,\n  capture: true,\n  passive: true\n}\n\nexport default IdleTimer\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => {},\n  onActive = () => {},\n  onAction = () => {},\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  stopOnIdle = false,\n  capture = true,\n  passive = true\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      emitOnIdle.current(e)\n    } else {\n      if (!stopOnIdle) {\n        idleTime.current += (+new Date()) - lastIdle.current\n        _bindEvents()\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    emitOnAction.current(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle.current) {\n      if (!stopOnIdle) {\n        tId.current = setTimeout(_toggleIdleState, _timeout.current)\n      }\n    } else {\n      tId.current = setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n * Restore initial state and restart timer\n * @name reset\n */\n  const reset = () => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = () => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = () => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create a throttle event handler if applicable\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    }\n\n    // Bind the events\n    _bindEvents()\n\n    // If startOnMount is enabled, start the timer\n    if (startOnMount) reset()\n\n    // Clear and unbind on unmount\n    return () => {\n      clearTimeout(tId.current)\n      _unbindEvents(true)\n    }\n  }, [])\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      emitOnAction.current = debounced(onAction, debounce)\n\n    // Create throttled action if applicable\n    } else if (throttle > 0) {\n      emitOnAction.current = throttled(onAction, throttle)\n\n    // No throttle or debounce\n    } else {\n      emitOnAction.current = onAction\n    }\n  }, [onAction])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (idle.current && !firstLoad.current) _toggleIdleState()\n    if (tId.current !== null) reset()\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  stopOnIdle: false,\n  capture: true,\n  passive: true\n}\n\nexport default useIdleTimer\n"],"names":["IS_BROWSER","window","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","debounced","fn","delay","timerId","args","clearTimeout","setTimeout","throttled","lastCall","now","Date","getTime","IdleTimer","Component","props","state","idle","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","tId","eventsBound","debounce","throttle","Error","_onAction","onAction","eventsThrottle","_handleEvent","_this","bind","startOnMount","_toggleIdleState","reset","pause","resume","isIdle","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","_bindEvents","this","prevProps","timeout","tid","_unbindEvents","children","element","events","passive","capture","forEach","e","addEventListener","_this2","force","removeEventListener","_this3","setState","prevState","_this4","onActive","onIdle","stopOnIdle","type","elapsedTimeSinceLastActive","timeLeft","useIdleTimer","useRef","firstLoad","_timeout","emitOnIdle","emitOnActive","emitOnAction","nextIdle","current","handleEvent","useEffect","propTypes","PropTypes","number","arrayOf","string","func","oneOfType","object","bool","defaultProps"],"mappings":"u3CAMO,IAAMA,EACuD,YAA/C,oBAAXC,4BAA8CA,OAArB,cAAqBA,SAO3CC,EAAkBF,EAAaG,SAAW,GAO1CC,EAAiB,CAC5B,YACA,UACA,QACA,iBACA,aACA,YACA,aACA,YACA,gBACA,gBACA,oBAaK,SAASC,EAAWC,EAAIC,OACzBC,SACG,sCAAaC,2BAAAA,kBACdD,GACFE,aAAaF,GAEfA,EAAUG,YAAW,WACnBL,eAAMG,GACND,EAAU,OACTD,IAaA,SAASK,EAAWN,EAAIC,OACzBM,EAAW,SACR,eACCC,GAAM,IAAIC,MAAOC,eACnBF,EAAMD,EAAWN,UAGrBM,EAAWC,EACJR,+BCtDLW,oPAAkBC,yCASTC,gIACLA,IAODC,MAAQ,CACXC,MAAM,EACNC,SAAU,IAAIP,KACdQ,YAAa,IAAIR,KACjBS,SAAU,KACVC,SAAU,EACVC,UAAW,KACXC,MAAO,KACPC,MAAO,QAQJC,IAAM,OAONC,aAAc,EAGfX,EAAMY,SAAW,GAAKZ,EAAMa,SAAW,QACnC,IAAIC,MAAM,mEAIdd,EAAMY,SAAW,IACdG,UAAY7B,EAAUc,EAAMgB,SAAUhB,EAAMY,UAGxCZ,EAAMa,SAAW,IACrBE,UAAYtB,EAAUO,EAAMgB,SAAUhB,EAAMa,UAGxCb,EAAMgB,WACVD,UAAYf,EAAMgB,WAIlBD,UAAY,aAIff,EAAMiB,eAAiB,IACpBC,aAAezB,EAAU0B,EAAKD,aAAaE,WAAYpB,EAAMiB,kBAE7DC,aAAeC,EAAKD,aAAaE,WAInCpB,EAAMqB,iBACJpB,MAAMC,MAAO,KAIfoB,iBAAmBH,EAAKG,iBAAiBF,aACzCG,MAAQJ,EAAKI,MAAMH,aACnBI,MAAQL,EAAKK,MAAMJ,aACnBK,OAASN,EAAKM,OAAOL,aACrBM,OAASP,EAAKO,OAAON,aACrBO,iBAAmBR,EAAKQ,iBAAiBP,aACzCQ,eAAiBT,EAAKS,eAAeR,aACrCS,kBAAoBV,EAAKU,kBAAkBT,aAC3CU,gBAAkBX,EAAKW,gBAAgBV,aACvCW,iBAAmBZ,EAAKY,iBAAiBX,aACzCY,mBAAqBb,EAAKa,mBAAmBZ,2EAW7Ca,cAEoBC,KAAKlC,MAAtBqB,cACUa,KAAKX,mDAGLY,GAEdA,EAAUvB,WAAasB,KAAKlC,MAAMY,gBAC/BG,UAAY7B,EAAUgD,KAAKnB,UAAWmB,KAAKlC,MAAMY,WAGpDuB,EAAUtB,WAAaqB,KAAKlC,MAAMa,gBAC/BE,UAAYtB,EAAUyC,KAAKnB,UAAWmB,KAAKlC,MAAMa,WAGpDsB,EAAUlB,iBAAmBiB,KAAKlC,MAAMiB,sBACrCC,aAAezB,EAAUyC,KAAKhB,aAAcgB,KAAKlC,MAAMiB,iBAG1DkB,EAAUC,UAAYF,KAAKlC,MAAMoC,UAC/BF,KAAKjC,MAAMC,MAAMgC,KAAKZ,mBACT,OAAbY,KAAKG,KAAcH,KAAKX,wDAY9BhC,aAAa2C,KAAKxB,UACb4B,eAAc,2CASEJ,KAAKlC,MAAlBuC,UACW,yDAUd1D,SAGyCqD,KAAKlC,MAA3CwC,IAAAA,QAASC,IAAAA,OAAQC,IAAAA,QAASC,IAAAA,QAC7BT,KAAKvB,cACR8B,EAAOG,SAAQ,SAAAC,GACbL,EAAQM,iBAAiBD,EAAGE,EAAK7B,aAAc,CAC7CyB,QAAAA,EACAD,QAAAA,YAGC/B,aAAc,uDAQRqC,6DAGRnE,SAEyCqD,KAAKlC,MAA3CwC,IAAAA,QAASC,IAAAA,OAAQC,IAAAA,QAASC,IAAAA,SAC9BT,KAAKvB,aAAeqC,KACtBP,EAAOG,SAAQ,SAAAC,GACbL,EAAQS,oBAAoBJ,EAAGK,EAAKhC,aAAc,CAChDyB,QAAAA,EACAD,QAAAA,YAGC/B,aAAc,6CASLkC,mBAIXM,UAAS,SAACC,SAAe,CAC5BlD,MAAOkD,EAAUlD,KACjBG,SAAW+C,EAAUlD,KAA4CkD,EAAU/C,UAA7C,IAAIT,KAAUyD,EAAKrD,MAAMoC,QACvD9B,SAAU8C,EAAUlD,KAAOkD,EAAU9C,WAAa,IAAIV,KAAUwD,EAAU/C,SAAW+C,EAAU9C,aAC7F,iBACuC+C,EAAKrD,MAAtCsD,IAAAA,SAAUC,IAAAA,OAAQC,IAAAA,WACTH,EAAKpD,MAAdC,MAEFsD,IAEFjE,aAAa8D,EAAK3C,KAClB2C,EAAK3C,IAAM,KAEX2C,EAAKf,iBAGPiB,EAAOV,IAEFW,IACHH,EAAKpB,cACLqB,EAAST,4CAWHA,SAC8BX,KAAKjC,MAAvCM,IAAAA,UAAWC,IAAAA,MAAOC,IAAAA,MAAOP,IAAAA,OACDgC,KAAKlC,MAA7BoC,IAAAA,QAASoB,IAAAA,mBAGZzC,UAAU8B,IAGXtC,MAGW,cAAXsC,EAAEY,KAAsB,IAEtBZ,EAAErC,QAAUA,GAASqC,EAAEpC,QAAUA,iBAId,IAAZoC,EAAErC,YAA4C,IAAZqC,EAAEpC,gBAK/ByB,KAAKN,iBACP,WAMhBrC,aAAa2C,KAAKxB,UACbA,IAAM,SAGLgD,GAA8B,IAAI9D,KAASsC,KAAKL,qBAGjD3B,IAASsD,IAAiBtD,GAAQwD,EAA6BtB,SAC7Dd,iBAAiBuB,QAKnBM,SAAS,CACZ/C,YAAa,IAAIR,KACjBY,MAAOqC,EAAErC,MACTC,MAAOoC,EAAEpC,QAKPP,GACGsD,SAIA9C,IAAMlB,WAAW0C,KAAKZ,iBAAkBc,qCAU/C7C,aAAa2C,KAAKxB,UACbA,IAAM,UAGNuB,mBAGAkB,SAAS,CACZjD,MAAM,EACNC,SAAU,IAAIP,KACdQ,YAAa,IAAIR,KACjBW,UAAW,WAIL6B,EAAYF,KAAKlC,MAAjBoC,aACH1B,IAAMlB,WAAW0C,KAAKZ,iBAAkBc,mCAU3B,OADIF,KAAKjC,MAAnBM,iBAIH+B,gBAGL/C,aAAa2C,KAAKxB,UACbA,IAAM,UAGNyC,SAAS,CACZ5C,UAAW2B,KAAKP,6DAUUO,KAAKjC,MAAzBM,IAAAA,UAAWL,IAAAA,KACD,OAAdK,SAGC0B,cAIA/B,SAEEQ,IAAMlB,WAAW0C,KAAKZ,iBAAkBf,QAExC4C,SAAS,CAAE5C,UAAW,KAAMH,YAAa,IAAIR,0DAUlBsC,KAAKjC,MAA/BM,IAAAA,UAAWH,IAAAA,WACXgC,EAAYF,KAAKlC,MAAjBoC,WAGU,OAAd7B,SACKA,EAAY,EAAI,EAAIA,MAIvBoD,EAAWvB,IAAa,IAAIxC,KAAUQ,UACrCuD,EAAW,EAAI,EAAIA,+CASlBxD,EAAY+B,KAAKjC,MAAjBE,eACC,IAAIP,KAAUO,mDASF+B,KAAKjC,MAAlBI,0DAU6B6B,KAAKjC,MAAlCC,IAAAA,KAAMG,IAAAA,SAAUC,IAAAA,gBACpBJ,GACQ,IAAIN,KAAUS,EAAYC,EAE7BA,qDAUc4B,KAAKjC,MAApBG,+DAUD8B,KAAKN,iBAAmBM,KAAKH,2DASnBG,KAAKjC,MAAdC,0CCnbZ,SAAS0D,iEAcL,OAbFxB,QAAAA,aAAU,WACVI,QAAAA,aAAUzD,QACV0D,OAAAA,aAASxD,QACTsE,OAAAA,aAAS,mBACTD,SAAAA,aAAW,mBACXtC,SAAAA,aAAW,mBACXJ,SAAAA,aAAW,QACXC,SAAAA,aAAW,QACXI,eAAAA,aAAiB,UACjBI,aAAAA,oBACAmC,WAAAA,oBACAb,QAAAA,oBACAD,QAAAA,gBAEM/B,EAAckD,UAAO,GACrB3D,EAAO2D,UAAO,GACd1D,EAAU0D,UAAQ,IAAIjE,MACtBW,EAAYsD,SAAO,MACnBrD,EAAQqD,SAAO,MACfpD,EAAQoD,SAAO,MACfnD,EAAMmD,SAAO,MACbzD,EAAayD,SAAO,MACpBxD,EAAWwD,SAAO,MAClBvD,EAAWuD,SAAO,GAClBC,EAAYD,UAAO,GACnBE,EAAWF,SAAOzB,GAGlB4B,EAAaH,SAAON,GACpBU,EAAeJ,SAAOP,GACtBY,EAAeL,SAAO7C,GAOtBM,EAAmB,SAAAuB,OACjBsB,GAAYjE,EAAKkE,QACvBlE,EAAKkE,QAAUD,EACXA,GACEX,IAEFjE,aAAamB,EAAI0D,SACjB1D,EAAI0D,QAAU,KAEd9B,KAEFjC,EAAS+D,SAAY,IAAIxE,KAAUmE,EAASK,QAC5CJ,EAAWI,QAAQvB,IAEdW,IACHlD,EAAS8D,UAAa,IAAIxE,KAAUS,EAAS+D,QAC7CnC,IACAgC,EAAaG,QAAQvB,KASrB3B,EAAe,SAAA2B,MAEnBqB,EAAaE,QAAQvB,IAGjBtC,EAAU6D,YAGC,cAAXvB,EAAEY,KAAsB,IAEtBZ,EAAErC,QAAUA,GAASqC,EAAEpC,QAAUA,iBAId,IAAZoC,EAAErC,YAA4C,IAAZqC,EAAEpC,gBAK/BmB,KACF,WAMhBrC,aAAamB,EAAI0D,SACjB1D,EAAI0D,QAAU,SAGRV,GAA8B,IAAI9D,KAASiC,MAI9C3B,EAAKkE,UAAYZ,IAChBtD,EAAKkE,SAAWV,EAA6BK,EAASK,UAExD9C,EAAiBuB,GAKnBzC,EAAWgE,SAAW,IAAIxE,KAC1BY,EAAM4D,QAAUvB,EAAErC,MAClBC,EAAM2D,QAAUvB,EAAEpC,MAIdP,EAAKkE,SACFZ,IAIL9C,EAAI0D,QAAU5E,WAAW8B,EAAkByC,EAASK,YAQlDC,EAAcR,SAAO3C,GAMrBe,EAAc,WAGbpD,IAGA8B,EAAYyD,UACf3B,EAAOG,SAAQ,SAAAC,GACbL,EAAQM,iBAAiBD,EAAGwB,EAAYD,QAAS,CAC/CzB,QAAAA,EACAD,QAAAA,OAGJ/B,EAAYyD,SAAU,KAQpB9B,EAAgB,eAACU,0DAGhBnE,IAED8B,EAAYyD,SAAWpB,KACzBP,EAAOG,SAAQ,SAAAC,GACbL,EAAQS,oBAAoBJ,EAAGwB,EAAYD,QAAS,CAClDzB,QAAAA,EACAD,QAAAA,OAGJ/B,EAAYyD,SAAU,IASpBzC,EAAmB,cAEG,OAAtBpB,EAAU6D,eACL7D,EAAU6D,QAAU,EAAI,EAAI7D,EAAU6D,YAIzCT,EAAWI,EAASK,UAAa,IAAIxE,KAAUQ,EAAWgE,gBACzDT,EAAW,EAAI,EAAIA,GAQtB/B,GAAiB,kBAAQ,IAAIhC,KAAUO,EAAQiE,SAO/CtC,GAAkB,kBAAMzB,EAAS+D,SAOjCrC,GAAmB,kBACnB7B,EAAKkE,SACG,IAAIxE,KAAUS,EAAS+D,QAAW9D,EAAS8D,QAE9C9D,EAAS8D,SASdvC,GAAoB,kBAAMzB,EAAWgE,SAOrCpC,GAAqB,kBAAMJ,KAAmBG,MAO9CL,GAAS,kBAAMxB,EAAKkE,SAMpB7C,GAAQ,WAEZhC,aAAamB,EAAI0D,SACjB1D,EAAI0D,QAAU,KAGdnC,IAGA/B,EAAKkE,SAAU,EACfjE,EAAQiE,SAAW,IAAIxE,KACvBQ,EAAWgE,SAAW,IAAIxE,KAC1BW,EAAU6D,QAAU,KAGpB1D,EAAI0D,QAAU5E,WAAW8B,EAAkByC,EAASK,UAOhD5C,GAAQ,WAEc,OAAtBjB,EAAU6D,UAGd9B,IAGA/C,aAAamB,EAAI0D,SACjB1D,EAAI0D,QAAU,KAGd7D,EAAU6D,QAAUzC,MAOhBF,GAAS,WAEa,OAAtBlB,EAAU6D,UAGdnC,IAIK/B,EAAKkE,UAER1D,EAAI0D,QAAU5E,WAAW8B,EAAkBf,EAAU6D,SAErD7D,EAAU6D,QAAU,KACpBhE,EAAWgE,SAAW,IAAIxE,eAO9B0E,aAAU,cAEJ1D,EAAW,GAAKC,EAAW,QACvB,IAAIC,MAAM,mEAIdG,EAAiB,IACnBoD,EAAYD,QAAU3E,EAAUyB,EAAcD,IAIhDgB,IAGIZ,GAAcE,KAGX,WACLhC,aAAamB,EAAI0D,SACjB9B,GAAc,MAEf,IAEHgC,aAAU,WACRN,EAAWI,QAAUb,IACpB,CAACA,IAEJe,aAAU,WACRL,EAAaG,QAAUd,IACtB,CAACA,IAEJgB,aAAU,WAGNJ,EAAaE,QADXxD,EAAW,EACU1B,EAAU8B,EAAUJ,GAGlCC,EAAW,EACGpB,EAAUuB,EAAUH,GAIpBG,IAExB,CAACA,IAEJsD,aAAU,WACRP,EAASK,QAAUhC,EACflC,EAAKkE,UAAYN,EAAUM,SAAS9C,IACpB,OAAhBZ,EAAI0D,SAAkB7C,KAC1BuC,EAAUM,SAAU,IACnB,CAAChC,IAEG,CACLV,OAAAA,GACAF,MAAAA,GACAD,MAAAA,GACAE,OAAAA,GACAK,gBAAAA,GACAC,iBAAAA,GACAF,kBAAAA,GACAG,mBAAAA,GACAJ,eAAAA,GACAD,iBAAAA,GDmFJ7B,EAAUyE,UAAY,CAMpBnC,QAASoC,EAAUC,OAMnBhC,OAAQ+B,EAAUE,QAAQF,EAAUG,QAMpCpB,OAAQiB,EAAUI,KAMlBtB,SAAUkB,EAAUI,KAMpB5D,SAAUwD,EAAUI,KAMpBhE,SAAU4D,EAAUC,OAMpB5D,SAAU2D,EAAUC,OAMpBxD,eAAgBuD,EAAUC,OAM1BjC,QAASgC,EAAUK,UAAU,CAACL,EAAUM,OAAQN,EAAUhC,UAM1DnB,aAAcmD,EAAUO,KAQxBvB,WAAYgB,EAAUO,KAMtBrC,QAAS8B,EAAUO,KAMnBpC,QAAS6B,EAAUO,MAQrBjF,EAAUkF,aAAe,CACvB5C,QAAS,KACTI,QAASzD,EACT0D,OAAQxD,EACRsE,OAAQ,aACRD,SAAU,aACVtC,SAAU,aACVJ,SAAU,EACVC,SAAU,EACVI,eAAgB,IAChBI,cAAc,EACdmC,YAAY,EACZb,SAAS,EACTD,SAAS,GC/KXkB,EAAaW,UAAY,CAMvBnC,QAASoC,EAAUC,OAMnBhC,OAAQ+B,EAAUE,QAAQF,EAAUG,QAMpCpB,OAAQiB,EAAUI,KAMlBtB,SAAUkB,EAAUI,KAMpB5D,SAAUwD,EAAUI,KAMpBhE,SAAU4D,EAAUC,OAMpB5D,SAAU2D,EAAUC,OAMpBxD,eAAgBuD,EAAUC,OAM1BjC,QAASgC,EAAUK,UAAU,CAACL,EAAUM,OAAQN,EAAUhC,UAM1DnB,aAAcmD,EAAUO,KAQxBvB,WAAYgB,EAAUO,KAMtBrC,QAAS8B,EAAUO,KAMnBpC,QAAS6B,EAAUO,MAQrBnB,EAAaoB,aAAe,CAC1B5C,QAAS,KACTI,QAASzD,EACT0D,OAAQxD,EACRsE,OAAQ,aACRD,SAAU,aACVtC,SAAU,aACVJ,SAAU,EACVC,SAAU,EACVI,eAAgB,IAChBI,cAAc,EACdmC,YAAY,EACZb,SAAS,EACTD,SAAS"}